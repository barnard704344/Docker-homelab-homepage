<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Homelab ‚Ä¢ Start</title>
  <script src="/js/utils.js"></script>
  <style>
    :root {
      --bg: #0f0f23;
      --fg: #cccccc;
      --border: #333;
      --accent: #009900;
      --accent-hover: #00cc00;
      --card-bg: #1a1a2e;
      --card-hover: #252547;
      --warning: #ff6b35;
      --missing-bg: rgba(255, 107, 53, 0.12);
      --missing-border: rgba(255, 107, 53, 0.5);
      --muted: #888;
    }
    
    * { box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--fg);
      margin: 0;
      padding: 20px;
      line-height: 1.4;
      min-height: 100vh;
    }
    
    header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    header h1 {
      font-size: 2rem;
      margin: 0;
      color: var(--accent);
    }
    
    .toolbar {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 10px 16px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--card-bg);
      color: var(--fg);
      cursor: pointer;
      text-decoration: none;
      font-size: 14px;
      transition: all 0.2s;
    }
    
    .btn:hover {
      background: var(--card-hover);
      border-color: var(--accent);
    }
    
    .btn.active {
      background: var(--accent);
      border-color: var(--accent);
    }
    
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .group {
      background: var(--card-bg);
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    
    .group-header {
      padding: 16px 20px;
      background: rgba(255,255,255,0.05);
      border-bottom: 1px solid var(--border);
      font-weight: 600;
      font-size: 18px;
    }
    
    .card {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      transition: background 0.2s;
      position: relative;
    }
    
    .card:last-child {
      border-bottom: none;
    }
    
    .card:hover {
      background: var(--card-hover);
    }

    .card.missing {
      border-left: 4px solid var(--missing-border);
      background: var(--missing-bg);
    }

    .card.missing:hover {
      background: rgba(255, 107, 53, 0.18);
    }

    .missing-banner {
      color: var(--warning);
      font-size: 13px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .missing-banner::before {
      content: '‚ö†Ô∏è';
    }

    .missing-info {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }
    
    .card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
    }
    
    .card-header img {
      flex-shrink: 0;
      border-radius: 2px;
    }
    
    .card-title {
      font-weight: 600;
      color: var(--fg);
      text-decoration: none;
      flex: 1;
    }
    
    .card-title:hover {
      color: var(--accent);
    }
    
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--muted);
      flex-shrink: 0;
    }
    
    .status-dot.online { background: var(--accent); }
    .status-dot.offline { background: var(--warning); }
    
    .card-desc {
      color: var(--muted);
      font-size: 14px;
      margin-bottom: 8px;
    }
    
    .card-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
    }
    
    .tag {
      background: rgba(255,255,255,0.1);
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      text-transform: uppercase;
      font-weight: 500;
    }
    
    .pin-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      background: none;
      border: none;
      color: var(--muted);
      cursor: pointer;
      font-size: 16px;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .pin-btn:hover {
      background: rgba(255,255,255,0.1);
    }
    
    .pin-btn.pinned {
      color: var(--accent);
    }
    
    .delete-btn {
      position: absolute;
      top: 12px;
      right: 40px;
      background: none;
      border: none;
      color: var(--muted);
      cursor: pointer;
      font-size: 14px;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .delete-btn:hover {
      background: rgba(255, 107, 53, 0.2);
      color: var(--warning);
    }
    
    .ports-section {
      margin: 8px 0;
      font-size: 12px;
      color: var(--muted);
    }
    
    .port-btn {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: var(--accent);
      cursor: pointer;
      font-size: 11px;
      padding: 2px 6px;
      margin: 0 2px;
      border-radius: 3px;
      transition: all 0.2s;
    }
    
    .port-btn:hover {
      background: var(--accent);
      color: white;
      transform: translateY(-1px);
    }
    
    .port-btn.selected {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    
    footer {
      text-align: center;
      color: var(--muted);
      font-size: 14px;
      margin-top: 40px;
    }
    
    .muted { color: var(--muted); }
    
    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
      }
      
      .search-box {
        max-width: none;
      }
      
      .grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>üè† Homelab</h1>
  </header>
  
  <main>
    <div class="toolbar">
      <button class="btn" id="toggle-pins">üìå Pinned</button>
      <button class="btn" id="refresh">üîÑ Refresh</button>
      <button class="btn" id="run-scan">üîç Run Scan</button>
      <div class="btn" id="scan-status" title="Click for scan details">üìä Status</div>
      <a href="/setup.html" class="btn">‚öôÔ∏è Setup</a>
    </div>
    
    <div id="grid" class="grid" aria-live="polite"></div>
    
    <footer class="muted">
      <p>Tip: pin your most used services with the üìå button</p>
      <p>
        <a href="/setup.html" style="color: var(--accent); font-size: 12px;">‚öôÔ∏è Setup Categories</a> | 
        <a href="#" onclick="checkDebug()" style="color: var(--muted); font-size: 12px;">Debug Info</a>
      </p>
    </footer>
  </main>

  <script>
    // --- STATIC LINKS (your own curated list)
    const LINKS = [
      { title: "Network Scan (Latest)", url: "/scan.txt", group: "Monitoring", desc: "Latest network scan results", tags: ["nmap", "scan", "network"], statusPath: "/" },
      { title: "Network Scan (Timestamped)", url: "/scan/last-scan.txt", group: "Monitoring", desc: "Timestamped scan results", tags: ["nmap", "scan", "network"], statusPath: "/" },
      // Add manually curated links here if needed
    ];

    // --- DYNAMIC LINKS from scanner
    let DYNAMIC_LINKS = [];
    
    // --- Server-side storage (primary source of truth)
    let serverPins = [];
    let serverPortSelections = {};
    
    // --- DOM references
    const grid = document.getElementById('grid');
    const togglePinsBtn = document.getElementById('toggle-pins');
    const refreshBtn = document.getElementById('refresh');
    const runScanBtn = document.getElementById('run-scan');
    const scanStatusBtn = document.getElementById('scan-status');
    
    let showingPinnedOnly = false;
    let scanStatusInterval;

    // --- Load dynamic links from services.json
    async function loadDynamicLinks() {
      try {
        const res = await fetch('setup-data.php?action=get_services&ts=' + Date.now(), { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}: no manifest`);
        const data = await res.json();
        const incoming = Array.isArray(data) ? data : (Array.isArray(data.links) ? data.links : []);
        DYNAMIC_LINKS = sanitizeLinks(incoming);
        
        // Apply category assignments from setup
        await applyCategoryAssignments();
      } catch (err) {
        console.log('Could not load services data:', err.message);
        DYNAMIC_LINKS = [];
      }
    }

    // --- Apply category assignments from setup page
    async function applyCategoryAssignments() {
      try {
        // Load category assignments
        const assignmentRes = await fetch('/setup-data.php?action=get_assignments', { cache: 'no-store' });
        if (!assignmentRes.ok) return; // No assignments yet, use defaults
        
        const assignments = await assignmentRes.json();
        
        // Load category names
        const categoriesRes = await fetch('/setup-data.php?action=get_categories', { cache: 'no-store' });
        if (!categoriesRes.ok) return; // No categories yet, use defaults
        
        const categories = await categoriesRes.json();
        
        // Apply assignments to services
        DYNAMIC_LINKS = DYNAMIC_LINKS.map(service => {
          const assignedCategory = assignments[service.title];
          if (assignedCategory && categories[assignedCategory]) {
            service.group = categories[assignedCategory];
          }
          return service;
        });
        
        console.log('Applied category assignments to', DYNAMIC_LINKS.length, 'services');
      } catch (err) {
        console.log('Could not load category assignments:', err.message);
      }
    }

    // --- Sanitize incoming links
    function sanitizeLinks(arr) {
      return arr.filter(x => x && x.title && x.url)
        .map(x => ({
          title: String(x.title),
          url: String(x.url),
          group: x.group ? String(x.group) : 'Discovered',
          desc: x.desc ? String(x.desc) : '',
          tags: Array.isArray(x.tags) ? x.tags.map(String) : [],
          statusPath: x.statusPath ? String(x.statusPath) : '/',
          status: typeof x.status === 'string' ? x.status : '',
          lastSeen: typeof x.last_seen === 'string' ? x.last_seen : (typeof x.lastSeen === 'string' ? x.lastSeen : ''),
          missingSince: typeof x.missing_since === 'string' ? x.missing_since : (typeof x.missingSince === 'string' ? x.missingSince : ''),
          ports: Array.isArray(x.ports) ? x.ports.map(p => ({
            port: String(p.port),
            service: String(p.service),
            url: String(p.url)
          })) : []
        }));
    }

    function formatTimestamp(isoString) {
      if (!isoString || typeof isoString !== 'string') {
        return '';
      }

      const parsed = new Date(isoString);
      if (Number.isNaN(parsed.getTime())) {
        return isoString;
      }

      return parsed.toLocaleString(undefined, {
        dateStyle: 'medium',
        timeStyle: 'short'
      });
    }

    // --- Merge and dedupe links
    function mergedLinks() {
      const seen = new Set();
      const out = [];
      const pinned = getPins(); // Get pinned services as objects
      const selectedPorts = getSelectedPorts(); // Get selected ports
      const pinnedTitles = new Set(pinned.map(p => p.title)); // Just get titles, don't add as separate entries
      const all = [...LINKS, ...DYNAMIC_LINKS]; // Don't include pinned as separate entries
      
      for (const link of all) {
        const urlKey = (link.url || '').toLowerCase();
        const titleKey = (link.title || '').toLowerCase();
        const key = urlKey || ('title:' + titleKey);
        
        if (!key || seen.has(key)) continue;
        seen.add(key);
        
        // Mark as pinned if it's in the pinned list
        const isPinned = pinnedTitles.has(link.title);
        if (isPinned) {
          link.isPinned = true;
          // Use pinned service's URL if it has a selected port
          const pinnedService = pinned.find(p => p.title === link.title);
          if (pinnedService && pinnedService.url !== link.url) {
            link.url = pinnedService.url;
          }
        }
        
        // Apply stored port selection to this link
        const selectedPort = selectedPorts[link.title];
        if (selectedPort && link.ports) {
          const portData = link.ports.find(p => p.port === selectedPort.port);
          if (portData) {
            link.url = portData.url;
            link.selectedPort = selectedPort.port;
          }
        }
        
        out.push(link);
      }
      
      return out;
    }

    // --- Group links by group property
    function groupsFromLinks(links) {
      const groups = new Map();
      
      for (const link of links) {
        const group = link.group || 'Other';
        if (!groups.has(group)) {
          groups.set(group, []);
        }
        groups.get(group).push(link);
      }
      
      // Sort groups: Core first, then alphabetical
      return new Map([...groups.entries()].sort(([a], [b]) => {
        if (a === 'Core') return -1;
        if (b === 'Core') return 1;
        return a.localeCompare(b);
      }));
    }

    // --- Get favicon URL
    function getFaviconUrl(url) {
      try {
        const domain = new URL(url).hostname;
        return `https://www.google.com/s2/favicons?domain=${domain}&sz=16`;
      } catch {
        return '';
      }
    }

    // --- Create group panel
    function groupPanel(groupName, links) {
      const panel = document.createElement('div');
      panel.className = 'group';
      
      const header = document.createElement('div');
      header.className = 'group-header';
      header.textContent = groupName;
      panel.appendChild(header);
      
      for (const link of links) {
        const card = createCard(link);
        panel.appendChild(card);
      }
      
      return panel;
    }

    // --- Create individual service card
    function createCard(link) {
      const card = document.createElement('div');
      card.className = 'card';

      const isPinned = getPins().some(p => p.title === link.title);
      const faviconUrl = getFaviconUrl(link.url);
      const selectedPorts = getSelectedPorts();
      const selectedPort = selectedPorts[link.title];
      const tags = Array.isArray(link.tags) ? link.tags.map(tag => String(tag)) : [];
      const isMissing = (link.status && link.status.toLowerCase() === 'missing') ||
        tags.some(tag => String(tag).toLowerCase() === 'missing');

      // Apply stored port selection
      let displayUrl = link.url;
      if (selectedPort && link.ports) {
        // Find the selected port in the ports array and use its URL
        const portData = link.ports.find(p => p.port === selectedPort.port);
        if (portData) {
          displayUrl = portData.url;
        }
      }

      const missingSinceText = formatTimestamp(link.missingSince);
      const lastSeenText = formatTimestamp(link.lastSeen);
      const missingBanner = isMissing ? `<div class="missing-banner">Missing${missingSinceText ? ` since ${escapeHtml(missingSinceText)}` : ''}</div>` : '';
      const missingInfo = isMissing && lastSeenText ? `<div class="missing-info">Last seen ${escapeHtml(lastSeenText)}</div>` : '';

      // Build ports section if available
      let portsHtml = '';
      if (link.ports && link.ports.length > 0) {
        const portButtons = link.ports.map(p => {
          const isSelected = selectedPort && selectedPort.port === p.port;
          const selectedClass = isSelected ? 'selected' : '';
          return `<button class="port-btn ${selectedClass}" data-url="${p.url}" data-port="${p.port}" data-service="${p.service}" data-title="${escapeHtml(link.title)}">${p.port}</button>`;
        }).join('');
        portsHtml = `<div class="ports-section">Ports: ${portButtons}</div>`;
      }

      card.innerHTML = `
        ${missingBanner}
        <div class="card-header">
          ${faviconUrl ? `<img src="${faviconUrl}" width="16" height="16" alt="" style="display: inline-block;" onerror="this.style.display='none'">` : '<span style="width:16px;height:16px;display:inline-block;"></span>'}
          <a href="${displayUrl}" class="card-title" target="_blank" rel="noopener">${escapeHtml(link.title)}</a>
          <div class="status-dot${isMissing ? ' offline' : ''}" data-url="${displayUrl}" data-path="${link.statusPath}"${isMissing ? ' data-status="missing"' : ''}></div>
        </div>
        ${missingInfo}
        ${portsHtml}
        <div class="card-meta">
          ${tags.map(tag => `<span class="tag">${escapeHtml(tag)}</span>`).join('')}
        </div>
        <button class="delete-btn" data-title="${escapeHtml(link.title)}" title="Delete service">
          üóëÔ∏è
        </button>
        <button class="pin-btn ${isPinned ? 'pinned' : ''}" data-title="${escapeHtml(link.title)}">
          ${isPinned ? 'üìç' : 'üìå'}
        </button>
      `;

      if (isMissing) {
        card.classList.add('missing');
        card.dataset.status = 'missing';
      }

      // Add pin button handler
      const pinBtn = card.querySelector('.pin-btn');
      pinBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        await togglePin(link.title);
        render();
      });
      
      // Add delete button handler
      const deleteBtn = card.querySelector('.delete-btn');
      deleteBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        if (confirm(`Delete "${link.title}"? It will be rediscovered on next scan if still active.`)) {
          await deleteService(link.title);
          render();
        }
      });
      
      // Add port button handlers
      const portBtns = card.querySelectorAll('.port-btn');
      portBtns.forEach(btn => {
        btn.addEventListener('click', async (e) => {
          e.preventDefault();
          const title = btn.dataset.title;
          const port = btn.dataset.port;
          const url = btn.dataset.url;
          const service = btn.dataset.service;
          await selectPort(title, port, url, service);
        });
      });
      
      return card;
    }
    
    // --- Port selection storage functions (server-primary for cross-device access)
    function getSelectedPorts() {
      return serverPortSelections;
    }

    async function setSelectedPort(serviceTitle, port, url) {
      serverPortSelections[serviceTitle] = { port, url };
      await syncPortSelectionsToServer(serverPortSelections);
    }

    async function removeSelectedPort(serviceTitle) {
      delete serverPortSelections[serviceTitle];
      await syncPortSelectionsToServer(serverPortSelections);
    }

    async function syncPortSelectionsToServer(selections) {
      try {
        const response = await fetch('port-selections.php', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'sync', selections: selections })
        });
        if (!response.ok) {
          console.error('Failed to save port selections to server');
        }
      } catch (error) {
        console.error('Error saving port selections to server:', error.message);
      }
    }

    async function loadPortSelectionsFromServer() {
      try {
        const response = await fetch('port-selections.php', { cache: 'no-store' });
        if (response.ok) {
          serverPortSelections = await response.json();
          if (typeof serverPortSelections !== 'object' || serverPortSelections === null) {
            serverPortSelections = {};
          }
        }
      } catch (error) {
        console.log('Note: Could not load port selections from server:', error.message);
        serverPortSelections = {};
      }
      return serverPortSelections;
    }

    // --- Port selection for discovered services
    async function selectPort(serviceTitle, port, url, service) {
      console.log('selectPort called:', { serviceTitle, port, url, service });
      
      const selected = getSelectedPorts();
      
      // Check if this port is already selected for this service
      if (selected[serviceTitle] && selected[serviceTitle].port === port) {
        // Unselect the port
        await removeSelectedPort(serviceTitle);
        
        // Revert to original URL (first port or default)
        const serviceIndex = DYNAMIC_LINKS.findIndex(s => s.title === serviceTitle);
        if (serviceIndex !== -1 && DYNAMIC_LINKS[serviceIndex].ports && DYNAMIC_LINKS[serviceIndex].ports.length > 0) {
          DYNAMIC_LINKS[serviceIndex].url = DYNAMIC_LINKS[serviceIndex].ports[0].url;
          DYNAMIC_LINKS[serviceIndex].selectedPort = null;
        }
      } else {
        // Select this port
        await setSelectedPort(serviceTitle, port, url);
        
        // Update the main URL for this service
        const serviceIndex = DYNAMIC_LINKS.findIndex(s => s.title === serviceTitle);
        if (serviceIndex !== -1) {
          DYNAMIC_LINKS[serviceIndex].url = url;
          DYNAMIC_LINKS[serviceIndex].selectedPort = port;
        }
      }
      
      console.log('Updated selections:', getSelectedPorts());
      
      // Re-render to update UI
      render();
    }

    // --- Escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // --- Pin management (server-primary storage for cross-device access)
    function getPins() {
      // Return server pins (loaded at startup)
      return serverPins;
    }

    async function setPins(pins) {
      serverPins = pins;
      // Save to server (primary storage)
      try {
        const response = await fetch('pins.php', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'sync', pins: pins })
        });
        if (!response.ok) {
          console.error('Failed to save pins to server');
        }
      } catch (error) {
        console.error('Error saving pins to server:', error.message);
      }
    }

    async function loadPinsFromServer() {
      try {
        const response = await fetch('pins.php', { cache: 'no-store' });
        if (response.ok) {
          serverPins = await response.json();
          if (!Array.isArray(serverPins)) serverPins = [];
        }
      } catch (error) {
        console.log('Note: Could not load pins from server:', error.message);
        serverPins = [];
      }
      return serverPins;
    }

    async function togglePin(title) {
      const pins = getPins();
      const selectedPorts = getSelectedPorts();
      
      if (pins.find(p => p.title === title)) {
        // Remove from pins
        const newPins = pins.filter(p => p.title !== title);
        await setPins(newPins);
      } else {
        // Find the service in either static or dynamic lists
        const staticService = LINKS.find(s => s.title === title);
        const dynamicService = DYNAMIC_LINKS.find(s => s.title === title);
        
        const service = staticService || dynamicService;
        
        if (service) {
          // Use selected port URL if one is chosen, otherwise use default URL
          let pinUrl = service.url;
          if (selectedPorts[title] && service.ports) {
            // Find the selected port data and use its URL
            const selectedPortData = service.ports.find(p => p.port === selectedPorts[title].port);
            if (selectedPortData) {
              pinUrl = selectedPortData.url;
            }
          }
          
          // Add to pins with selected URL, keeping original group/category
          const pinData = {
            title: service.title,
            url: pinUrl,
            group: service.group || service.category || 'Uncategorized',
            desc: service.desc,
            tags: ['pinned'].concat(service.tags || []),
            ports: service.ports || [],
            selectedPort: selectedPorts[title] ? selectedPorts[title].port : null
          };
          
          pins.push(pinData);
          await setPins(pins);
        }
      }
    }

    function getPinnedServices() {
      return getPins();
    }
    
    // --- Delete service functions
    function deleteService(title) {
      // Call backend to permanently delete the service
      deleteServiceFromBackend(title);
    }

    async function deleteServiceFromBackend(title) {
      try {
        // Send to backend to actually delete from services data
        const response = await fetch('setup-data.php', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'delete_service',
            service_name: title
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          if (result.success) {
            console.log(`Service '${title}' permanently deleted from backend`);
            
            // Remove from current display immediately
            DYNAMIC_LINKS = DYNAMIC_LINKS.filter(s => s.title !== title);
            render();
            return true;
          } else {
            console.error('Backend deletion failed:', result.error);
          }
        } else {
          console.error('HTTP error during deletion:', response.status);
        }
      } catch (error) {
        console.error('Error deleting service from backend:', error);
      }
      return false;
    }

    // --- Main render function
    function render() {
      grid.innerHTML = '';
      let links = mergedLinks();

      // Filter by pinned if active
      if (showingPinnedOnly) {
        links = links.filter(link => link.isPinned);
      }

      const groups = groupsFromLinks(links);
      
      if (groups.size === 0) {
        grid.innerHTML = '<div style="text-align: center; color: var(--muted); padding: 40px;">No services found</div>';
        return;
      }
      
      for (const [name, groupLinks] of groups) {
        grid.appendChild(groupPanel(name, groupLinks));
      }
      
      // Start status checks
      checkVisible();
    }

    // --- Status checking
    async function checkVisible() {
      const dots = document.querySelectorAll('.status-dot[data-url]');
      
      for (const dot of dots) {
        checkStatus(dot);
      }
    }

    async function checkStatus(dot) {
      const url = dot.dataset.url;
      const path = dot.dataset.path || '/';
      const dotStatus = (dot.dataset.status || '').toLowerCase();

      if (dotStatus === 'missing') {
        dot.className = 'status-dot offline';
        return;
      }

      try {
        // For local files (starting with /), use a different approach
        if (url.startsWith('/')) {
          const response = await fetch(url, {
            method: 'HEAD',
            cache: 'no-cache'
          });
          dot.className = response.ok ? 'status-dot online' : 'status-dot offline';
          return;
        }
        
        // For external URLs
        const checkUrl = new URL(path, url).toString();
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        
        const response = await fetch(checkUrl, {
          method: 'HEAD',
          signal: controller.signal,
          mode: 'no-cors'
        });
        
        clearTimeout(timeoutId);
        dot.className = 'status-dot online';
      } catch (error) {
        dot.className = 'status-dot offline';
      }
    }

    // --- Event listeners
    togglePinsBtn.addEventListener('click', () => {
      showingPinnedOnly = !showingPinnedOnly;
      togglePinsBtn.classList.toggle('active', showingPinnedOnly);
      togglePinsBtn.textContent = showingPinnedOnly ? 'üìç All' : 'üìå Pinned';
      render();
    });

    refreshBtn.addEventListener('click', async () => {
      refreshBtn.textContent = '‚è≥ Loading...';
      await loadPinsFromServer();
      await loadPortSelectionsFromServer();
      await loadDynamicLinks();
      render();
      refreshBtn.textContent = 'üîÑ Refresh';
      
      // Show a brief success indicator
      setTimeout(() => {
        refreshBtn.textContent = '‚úÖ Refreshed';
        setTimeout(() => {
          refreshBtn.textContent = 'üîÑ Refresh';
        }, 1500);
      }, 100);
    });

    // --- Run Scan button handler
    runScanBtn.addEventListener('click', async () => {
      if (runScanBtn.classList.contains('active')) {
        // Already scanning, show status
        alert('A scan is already in progress. Please wait for it to complete.');
        return;
      }
      
      if (!confirm('Start a network scan? This will discover services on your network and may take a few minutes.')) {
        return;
      }
      
      runScanBtn.textContent = '‚è≥ Starting...';
      runScanBtn.classList.add('active');
      
      try {
        const response = await fetch('/run-scan.php', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        
        if (response.ok) {
          const result = await response.json();
          console.log('Scan started:', result);
          runScanBtn.textContent = 'üîç Scanning...';
          
          // Start polling for scan completion
          pollScanProgress();
        } else {
          throw new Error('Failed to start scan');
        }
      } catch (error) {
        console.error('Error starting scan:', error);
        runScanBtn.textContent = '‚ùå Failed';
        runScanBtn.classList.remove('active');
        setTimeout(() => {
          runScanBtn.textContent = 'üîç Run Scan';
        }, 2000);
        alert('Failed to start scan: ' + error.message);
      }
    });

    // --- Poll for scan progress
    async function pollScanProgress() {
      const pollInterval = setInterval(async () => {
        try {
          const response = await fetch('/scan-progress.php', { cache: 'no-store' });
          if (response.ok) {
            const progress = await response.json();
            
            if (progress.status === 'idle' || progress.status === 'complete' || progress.status === 'completed') {
              clearInterval(pollInterval);
              runScanBtn.textContent = '‚úÖ Complete';
              runScanBtn.classList.remove('active');
              
              // Reload services after scan completes
              setTimeout(async () => {
                await loadDynamicLinks();
                render();
                runScanBtn.textContent = 'üîç Run Scan';
                checkScanStatus(); // Update the status display
              }, 1500);
            } else if (progress.status === 'scanning' || progress.status === 'parsing' || progress.status === 'starting') {
              const pct = progress.progress || 0;
              runScanBtn.textContent = `üîç ${pct}%`;
            }
          }
        } catch (error) {
          console.log('Polling error:', error);
        }
      }, 2000);
      
      // Stop polling after 5 minutes (failsafe)
      setTimeout(() => {
        clearInterval(pollInterval);
        if (runScanBtn.classList.contains('active')) {
          runScanBtn.textContent = 'üîç Run Scan';
          runScanBtn.classList.remove('active');
        }
      }, 300000);
    }

    // --- Check scan status periodically
    async function checkScanStatus() {
      try {
        const response = await fetch('/scan-status.php', {
          method: 'GET',
          cache: 'no-cache'
        });
        
        if (response.ok) {
          const status = await response.text();
          
          if (status.includes('running') || status.includes('scanning')) {
            scanStatusBtn.textContent = '‚è≥ Scanning...';
            scanStatusBtn.classList.add('active');
            runScanBtn.textContent = 'üîç Scanning...';
            runScanBtn.classList.add('active');
            return;
          }
        }
        
        // Not currently scanning, check scan file status
        let scanFound = false;
        let scanTime = null;
        
        // Try multiple scan file locations
        const scanPaths = ['/scan.txt', '/scan/last-scan.txt', '/data/scan.txt', '/data/scan/last-scan.txt'];
        
        for (const path of scanPaths) {
          try {
            const scanResponse = await fetch(path, { method: 'HEAD', cache: 'no-cache' });
            if (scanResponse.ok) {
              const lastModified = scanResponse.headers.get('last-modified');
              if (lastModified) {
                scanTime = new Date(lastModified);
                scanFound = true;
                break;
              }
            }
          } catch (e) {
            continue;
          }
        }
        
        if (scanFound && scanTime) {
          const now = new Date();
          const minutesAgo = Math.floor((now - scanTime) / (1000 * 60));
          
          // Reset scan button if not actively scanning
          runScanBtn.textContent = 'üîç Run Scan';
          runScanBtn.classList.remove('active');
          
          if (minutesAgo < 1) {
            scanStatusBtn.textContent = '‚úÖ Just Scanned';
          } else if (minutesAgo < 60) {
            scanStatusBtn.textContent = `üìä ${minutesAgo}m ago`;
          } else {
            const hoursAgo = Math.floor(minutesAgo / 60);
            scanStatusBtn.textContent = `üìä ${hoursAgo}h ago`;
          }
        } else {
          // No scan found - prompt user to run a scan
          scanStatusBtn.textContent = 'üìä No scans yet';
          scanStatusBtn.classList.remove('active');
          runScanBtn.textContent = 'üîç Run Scan';
          runScanBtn.classList.remove('active');
          return;
        }
        
        scanStatusBtn.classList.remove('active');
        
      } catch (error) {
        // Ultimate fallback
        scanStatusBtn.textContent = 'üîç Scan Status';
        scanStatusBtn.classList.remove('active');
      }
    }

    // --- Utility functions
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // --- Initialize app
    (async () => {
      await loadPinsFromServer(); // Load pins from server first
      await loadPortSelectionsFromServer(); // Load port selections from server
      await loadDynamicLinks();
      render();
      
      // Start scan status checking
      checkScanStatus(); // Initial check
      scanStatusInterval = setInterval(checkScanStatus, 30000); // Check every 30 seconds
    })();

    // --- Debug function
    async function checkDebug() {
      try {
        const response = await fetch('/debug.php');
        const data = await response.json();
        
        console.log('Debug Info:', data);
        const links = mergedLinks();
        
        alert(`Debug Info:
Services file exists: ${data.services_exists}
Services file size: ${data.services_size} bytes
Scan file exists: ${data.scan_exists}
Scan file size: ${data.scan_size} bytes

Total links loaded: ${links.length}
Static links: ${LINKS.length}
Dynamic links: ${DYNAMIC_LINKS.length}

Check browser console for full details.`);
        
        if (data.services_content) {
          console.log('Services.json content:', JSON.parse(data.services_content));
        }
        
      } catch (error) {
        console.error('Debug failed:', error);
        alert('Debug failed - check console');
      }
    }
  </script>
</body>
</html>
